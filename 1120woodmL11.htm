<meta charset="utf-8" lang="en">            <style class="fallback">body{visibility:hidden;}</style>
<!---


                       DOWNLOAD AND OPEN IN A BROWSER
                          TO SEE PROPER FORMATTING


--->
**Lab 11: Auto Complete**
    Username: woodm
    Date: 11-13-2023
    Course: CSC1120
    Submitted to: Dr. Chris Taylor

!!! METRIcS: Instructor Feedback
    | Earned | Possible | Criteria                                         |
    | ------ | -------- | ------------------------------------------------ |
    |   50   |    50    | Technical quality (see point deductions in code) |
    |   20   |    20    | GUI Layout / Functionality                       |
    |   15   |    15    | Intermediate commits                             |
    |   10   |    10    | Coding standard compliance and program clarity   |
    |    5   |     5    | Following submission instructions                |

    [Nicely Done](https://msoe.us/taylor/Nice)

# AutoComplete.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;

/**
 * The Driver used to run the program.
 */
public class AutoComplete extends Application {
    public void start(Stage stage) {
        try {
            Parent pane = FXMLLoader.load(getClass().getResource("layout.fxml"));
            stage.setScene(new Scene(pane));
            stage.setTitle("Auto Complete");
            stage.setResizable(false);
            stage.show();
        } catch (IOException e) {
            System.out.println("There was an error reading the FXML file, please try again");
        }
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}

~~~~

# AutoCompleter.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/5/2024
 */
package woodm;

/**
 * The AutoCompleter interface represents an interface for implementing an auto-completion system
 * in your program. This interface defines methods and functionality related to providing
 * suggestions or completions based on user input.
 */
public interface AutoCompleter {
    /**
     * Adds a word to the AutoCompleter if the word is valid.
     * Duplicates and null values aren't allowed to be added.
     * @param word a string that is to be added to the AutoCompleter.
     * @return true if word is added to the object,
     * false if the word is already in the AutoCompleter.
     *
     * @throws IllegalArgumentException thrown if word is null or an empty string.
     */
    boolean add(String word) throws IllegalArgumentException;

    /**
     * Searches for a target in the AutoCompleter and returns true if it was found, false if not.
     * @param target the target to search for.
     * @return true if target is found in the AutoCompleter,
     * false if target is null or an empty string, or it was not found.
     */
    boolean exactMatch(String target);

    /**
     * Returns an integer representing the number of items in the AutoCompleter.
     * @return the number of items in the AutoCompleter.
     */
    int size();

    /**
     * returns a String indicating the fully qualified name of the data structure used to store
     * the words for the AutoCompleter.
     * @return a String indicating the name of the data structure used to store the words.
     */
    String getBackingClass();

    /**
     * Returns an array of all the strings in the object that begin with the prefix.
     * If prefix is an empty string, an array of all the strings in the auto completer are returned.
     * If prefix is null, an empty array is returned.
     * @param prefix the prefix to compare the words in the AutoCompleter to.
     * @return an array of all the strings in the object that begin with the prefix.
     */
    String[] allMatches(String prefix);

    /**
     * Returns a human-friendly string representing the number of nanoseconds.
     * @param nanoseconds the amount of nanoseconds it takes to complete the operation.
     * @return a human-friendly string representing the number of nanoseconds.
     */
    static String format(long nanoseconds) {
        final long nsInDay = 86_400_000_000_000L;
        final long nsToHr = 3_600_000_000_000L;
        final long nsInMin = 60_000_000_000L;
        final long nsInS = 1_000_000_000;
        final long nsInMs = 1_000_000;
        final long nsInMicros = 1_000;
        String time;
        if(nanoseconds / nsInDay >= 1) { // 2 day(s) 5 hour(s) 32 minute(s)
            long days = nanoseconds / nsInDay;
            nanoseconds %= nsInDay;
            long hours = nanoseconds / nsToHr;
            nanoseconds %= nsToHr;
            long minutes = Math.round((double) nanoseconds / nsInMin);
            time = days + " day(s) " + hours + " hour(s) " + minutes + " minute(s)";
        } else if(nanoseconds / nsToHr >= 1) { // 14 hour(s) 22 minute(s) 8 second(s)
            long hours = nanoseconds / nsToHr;
            nanoseconds %= nsToHr;
            long minutes = nanoseconds / nsInMin;
            nanoseconds %= nsInMin;
            long seconds = Math.round((double) nanoseconds / nsInS);
            time = hours + " hour(s) " + minutes + " minute(s) " + seconds + " second(s)";
        } else if(nanoseconds / nsInMin >= 1) { // 42 minute(s) 55.3 second(s)
            long minutes = nanoseconds / nsInMin;
            nanoseconds %= nsInMin;
            double seconds = (double) nanoseconds / nsInS;
            time = String.format("%d minute(s) %.1f second(s)", minutes, seconds);
        } else if(nanoseconds / nsInS >= 1) { // 18.8 second(s)
            double seconds = (double) nanoseconds / nsInS;
            time = String.format("%.1f second(s)", seconds);
        } else if(nanoseconds / nsInMs >= 1) { // 998.8 millisecond(s)
            double milliseconds = (double) nanoseconds / nsInMs;
            time = String.format("%.1f millisecond(s)", milliseconds);
        } else if(nanoseconds / nsInMicros >= 1) { // 318.8 microsecond(s)
            double microseconds = (double) nanoseconds / nsInMicros;
            time = String.format("%.1f microsecond(s)", microseconds);
        } else { // 7 nanosecond(s)
            time = nanoseconds + " nanosecond(s)";
        }
        return time;
    }
}

~~~~

# AutoCompleterTest.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/7/2024
 */
package woodm;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests to ensure all implementations of the AutoCompleter interface work properly.
 */
class AutoCompleterTest {
    private AutoCompleter autoCompleter;

    @BeforeEach
    void setUp() {
        autoCompleter = new OrderedList(new ArrayList&lt&#xFEFF;>());
    }

    @AfterEach
    void tearDown() {
        autoCompleter = null;
    }

    @Test
    void getBackingClassTest() {
        autoCompleter = new UnorderedList(new ArrayList&lt&#xFEFF;>());
        assertEquals("java.util.ArrayList", autoCompleter.getBackingClass());
        autoCompleter = new OrderedList(new LinkedList&lt&#xFEFF;>());
        assertEquals("java.util.LinkedList", autoCompleter.getBackingClass());
        autoCompleter = new BinarySearchTree(new ArrayList&lt&#xFEFF;>());
        assertEquals("java.util.TreeSet", autoCompleter.getBackingClass());
    }

    @Test
    void addTest() {
        assertTrue(autoCompleter.add("Hello"));
        assertFalse(autoCompleter.add("Hello"));
        assertThrows(IllegalArgumentException.class, () -> autoCompleter.add(""));
        assertThrows(IllegalArgumentException.class, () -> autoCompleter.add(null));
    }

    @Test
    void sizeTest() {
        assertEquals(0, autoCompleter.size());
        autoCompleter.add("Hello");
        assertEquals(1, autoCompleter.size());
        autoCompleter.add("Hello");
        assertEquals(1, autoCompleter.size());
    }

    @Test
    void exactMatchTest() {
        autoCompleter.add("Hello");
        assertTrue(autoCompleter.exactMatch("Hello"));
        assertFalse(autoCompleter.exactMatch("hello"));
        assertFalse(autoCompleter.exactMatch(null));
        assertFalse(autoCompleter.exactMatch(""));
    }

    @Test
    void allMatchesTest() {
        autoCompleter.add("hello");
        autoCompleter.add("hello world");
        autoCompleter.add("Hello");
        autoCompleter.add("hi");
        autoCompleter.add("help!");
        autoCompleter.add("h");
        String[] helMatches = {"hello", "hello world", "help!"};
        String[] hMatches = {"hello", "hello world", "hi", "help!", "h"};
        String[] matches = {"hello", "hello world", "Hello", "hi", "help!", "h"};
        if(autoCompleter instanceof OrderedList || autoCompleter instanceof BinarySearchTree) {
            Arrays.sort(helMatches);
            Arrays.sort(hMatches);
            Arrays.sort(matches);
        }
        assertArrayEquals(helMatches, autoCompleter.allMatches("hel"));
        assertArrayEquals(hMatches, autoCompleter.allMatches("h"));
        assertArrayEquals(new String[0], autoCompleter.allMatches(null));
        assertArrayEquals(new String[0], autoCompleter.allMatches("HI"));
        assertArrayEquals(matches, autoCompleter.allMatches(""));
    }

    @Test
    void formatTest() {
        final long test1 = 192_720_000_000_000L;
        final long test2 = 51_728_000_000_000L;
        final long test3 = 2_575_300_000_000L;
        final long test4 = 18_800_000_000L;
        final long test5 = 998_800_000;
        final long test6 = 318_800;
        final long test7 = 7;
        final long test8 = 998_799_980;
        final long test9 = 51_727_999_999_980L;
        long nanoseconds = test1;
        assertEquals("2 day(s) 5 hour(s) 32 minute(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test2;
        assertEquals("14 hour(s) 22 minute(s) 8 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test3;
        assertEquals("42 minute(s) 55.3 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test4;
        assertEquals("18.8 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test5;
        assertEquals("998.8 millisecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test6;
        assertEquals("318.8 microsecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test7;
        assertEquals("7 nanosecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test8;
        assertEquals("998.8 millisecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test9;
        assertEquals("14 hour(s) 22 minute(s) 8 second(s)", AutoCompleter.format(nanoseconds));
    }
}


/*
  Discussion: What method did you find most difficult to test? Why?

  I thought the allMatches() method was the most difficult to test because
  I was originally comparing the results of the method to another String array that has the
  same contents as what was expected. This resulted in the test failing when I used
  assertEquals because they aren't the same object. I then decided to use Arrays.equals inside
  the assertEquals and this worked. Then, I found out that the assertArrayEquals is the
  simplified version of this and that is what I ended up using.

*/

~~~~

# BinarySearchTree.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 4/4/2024
 */
package woodm;

import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A BinarySearchTree is a Binary Search Tree
 * that has a TreeSet backing class which doesn't allow duplicates.
 */
public class BinarySearchTree implements AutoCompleter {
    private final TreeSet&lt&#xFEFF;String> items;

    /**
     * Creates a new BinarySearchTree and adds all nodes from the treeSet
     * into the backing tree.
     * @param list the original tree set to pass in.
     *
     * @throws IllegalArgumentException thrown if the original tree set is null.
     */
    public BinarySearchTree(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = new TreeSet&lt&#xFEFF;>(list);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        return this.items.add(word);
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && this.items.contains(target);
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                SortedSet&lt&#xFEFF;String> matchSet =
                        this.items.subSet(prefix, prefix + Character.MAX_VALUE);
                matches = matchSet.toArray(new String[0]);
            }
        }
        return matches;
    }
}

~~~~

# Controller.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.stage.FileChooser;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 * The Controller class is used to add functionality to the layout.fxml GUI
 */
public class Controller {
    private static final String DATA_FOLDER = "data/";
    @FXML
    private Button selectFileButton;
    @FXML
    private TextField searchBar;
    @FXML
    private ListView&lt&#xFEFF;String> listView;
    @FXML
    private TextField uLExactTime;
    @FXML
    private TextField uLAllMatchesTime;
    @FXML
    private TextField sLExactTime;
    @FXML
    private TextField sLAllMatchesTime;
    @FXML
    private TextField bSTExactTime;
    @FXML
    private TextField bSTAllMatchesTime;
    @FXML
    private Button unsortedListALButton;
    @FXML
    private Button unsortedListLLButton;
    @FXML
    private Button sortedListALButton;
    @FXML
    private Button sortedListLLButton;
    private File dataFile;
    private AutoCompleter unorderedList;
    private AutoCompleter orderedList;
    private AutoCompleter binarySearchTree;
    private List&lt&#xFEFF;String> unorderedListBackingList;
    private List&lt&#xFEFF;String> orderedListBackingList;
    private final Background greenBackground;

    /**
     * Initializes the Controller and
     * initializes the unorderedListBackingList
     * and the orderedListBackingList
     * to empty ArrayLists
     */
    public Controller() {
        unorderedListBackingList = new ArrayList&lt&#xFEFF;>();
        orderedListBackingList = new ArrayList&lt&#xFEFF;>();
        greenBackground = new Background(
                new BackgroundFill(Color.LIGHTGREEN, null, null));
    }

    @FXML
    private void selectFile() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("Text Files", "*.txt"));
        fileChooser.setInitialDirectory(new File(DATA_FOLDER));
        File temp = fileChooser.showOpenDialog(null);
        if(temp != null) {
            if(unorderedListBackingList instanceof ArrayList&lt&#xFEFF;String>
                    && orderedListBackingList instanceof ArrayList&lt&#xFEFF;String>) {
                unsortedListALButton.setBackground(greenBackground);
                sortedListALButton.setBackground(greenBackground);
            }
            listView.getItems().clear();
            searchBar.setText("");
            changeTimesTextField(null, "", "", null);
            this.dataFile = temp;
            selectFileButton.setText(this.dataFile.getName());
            searchBar.setEditable(true);
            processFile();
            unsortedListALButton.setDisable(false);
            unsortedListLLButton.setDisable(false);
            sortedListALButton.setDisable(false);
            sortedListLLButton.setDisable(false);
        }
    }

    @FXML
    private void createBackingList(ActionEvent event) {
        Button button = (Button) event.getSource();
        String listType = ((Label) ((HBox) button.getParent()).getChildren().getFirst()).getText();
        if(button.getText().equals("LL")) {
            if(listType.equals("Unsorted List")
                    && !(unorderedListBackingList instanceof LinkedList&lt&#xFEFF;String>)) {
                unorderedListBackingList = new LinkedList&lt&#xFEFF;>(unorderedListBackingList);
                unorderedList = new UnorderedList(unorderedListBackingList);
                unsortedListLLButton.setBackground(greenBackground);
                unsortedListALButton.setBackground(null);
            } else if(listType.equals("Sorted List")
                    && !(orderedListBackingList instanceof LinkedList&lt&#xFEFF;String>)) {
                orderedListBackingList = new LinkedList&lt&#xFEFF;>(orderedListBackingList);
                orderedList = new OrderedList(orderedListBackingList);
                sortedListLLButton.setBackground(greenBackground);
                sortedListALButton.setBackground(null);
            }
        } else {
            if(listType.equals("Unsorted List")
                    && !(unorderedListBackingList instanceof ArrayList&lt&#xFEFF;String>)) {
                unorderedListBackingList = new ArrayList&lt&#xFEFF;>(unorderedListBackingList);
                unorderedList = new UnorderedList(unorderedListBackingList);
                unsortedListALButton.setBackground(greenBackground);
                unsortedListLLButton.setBackground(null);
            } else if(listType.equals("Sorted List")
                    && !(orderedListBackingList instanceof ArrayList&lt&#xFEFF;String>)) {
                orderedListBackingList = new ArrayList&lt&#xFEFF;>(orderedListBackingList);
                orderedList = new OrderedList(orderedListBackingList);
                sortedListALButton.setBackground(greenBackground);
                sortedListLLButton.setBackground(null);
            }
        }
    }

    private void processFile() {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        try (Scanner reader = new Scanner(dataFile)) {
            while(reader.hasNextLine()) {
                String line = reader.nextLine();
                unorderedListBackingList.add(line);
                orderedListBackingList.add(line);
            }
            unorderedList = new UnorderedList(unorderedListBackingList);
            orderedList = new OrderedList(orderedListBackingList);
            binarySearchTree = new BinarySearchTree(unorderedListBackingList);
        } catch (IOException e) {
            alert.setContentText("The file could not be read, please try again");
            alert.showAndWait();
        } catch (IllegalArgumentException e) {
            alert.setContentText(e.getMessage());
            alert.showAndWait();
        }
    }

    @FXML
    private void updateList() {
        if(searchBar.isEditable()) {
            listView.getItems().clear();
            String text = searchBar.getText();
            updateTimes(unorderedList, text);
            updateTimes(orderedList, text);
            updateTimes(binarySearchTree, text);
        }
    }

    private void updateTimes(AutoCompleter autoCompleter, String text) {
        long startTime = System.nanoTime();
        autoCompleter.exactMatch(text);
        String exactMatchTime = AutoCompleter.format(System.nanoTime() - startTime);
        startTime = System.nanoTime();
        String[] allMatches = autoCompleter.allMatches(text);
        String allMatchesTime = AutoCompleter.format(System.nanoTime() - startTime);
        changeTimesTextField(autoCompleter, exactMatchTime, allMatchesTime, allMatches);
    }

    private void changeTimesTextField(AutoCompleter autoCompleter, String exactMatchTime,
                                      String allMatchesTime, String[] allMatches) {
        if(autoCompleter instanceof UnorderedList) {
            uLExactTime.setText(exactMatchTime);
            uLAllMatchesTime.setText(allMatchesTime);
        } else if(autoCompleter instanceof OrderedList) {
            sLExactTime.setText(exactMatchTime);
            sLAllMatchesTime.setText(allMatchesTime);
            listView.getItems().addAll(allMatches);
        } else if(autoCompleter instanceof BinarySearchTree) {
            bSTExactTime.setText(exactMatchTime);
            bSTAllMatchesTime.setText(allMatchesTime);
        } else {
            uLExactTime.setText("");
            uLAllMatchesTime.setText("");
            sLExactTime.setText("");
            sLAllMatchesTime.setText("");
            bSTExactTime.setText("");
            bSTAllMatchesTime.setText("");
        }
    }
}

~~~~

# OrderedList.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

/**
 * An OrderedList is a list that has an order and doesn't allow duplicates.
 */
public class OrderedList implements AutoCompleter {
    private final List&lt&#xFEFF;String> items;

    /**
     * Creates a new OrderedList that removes all duplicates from the original list
     * and puts all items in order alphabetically.
     * @param list the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public OrderedList(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = list;
        Set&lt&#xFEFF;String> unique = new HashSet&lt&#xFEFF;>(list);
        this.items.clear();
        this.items.addAll(unique);
        Collections.sort(items);
~~~~ Java highlight
    }
    @Override
~~~~
!!! FEEDBACK: Use blank lines to help organize visually
    I would recommend using a blank line to separate each of these methods.
    Doing so makes the code a little be easier to scan since it the blank
    lines visually separate the various methods.

~~~~ Java
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        boolean changed = false;
        ListIterator&lt&#xFEFF;String> iterator = this.items.listIterator();
        if(!items.contains(word)) {
            if (!iterator.hasNext() && !iterator.hasPrevious()) {
                iterator.add(word);
                changed = true;
            } else if (iterator.hasNext() && iterator.next().compareTo(word) &lt&#xFEFF; 0) {
                iterator.previous();
                while (iterator.hasNext() && !changed) {
                    String currentWord = iterator.next();
                    if (currentWord.compareTo(word) > 0) {
                        iterator.previous();
                        iterator.add(word);
                        changed = true;
                    }
                }
                if(!changed) {
                    iterator.add(word);
                    changed = true;
                }
            } else {
                if(iterator.hasPrevious()) {
                    iterator.previous();
                }
                iterator.add(word);
                changed = true;
            }
        }
        return changed;
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty()
                && Collections.binarySearch(this.items, target) >= 0;
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                int index = Collections.binarySearch(this.items, prefix);
                if(index &lt&#xFEFF; 0) {
                    index = -index - 1;
                }
                List&lt&#xFEFF;String> matchesList = new ArrayList&lt&#xFEFF;>();
                while(index &lt&#xFEFF; items.size() && items.get(index).startsWith(prefix)) {
                    matchesList.add(items.get(index));
                    index++;
                }
                matches = matchesList.toArray(new String[0]);
            }
        }
        return matches;
    }
}

~~~~

# UnorderedList.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/7/2024
 */
package woodm;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * An UnorderedList is a list that has no order and doesn't allow duplicates.
 */
public class UnorderedList implements AutoCompleter {
    private final List&lt&#xFEFF;String> items;

    /**
     * Creates a new UnorderedList that removes all duplicates from the original list.
     * @param list the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public UnorderedList(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = list;
        Set&lt&#xFEFF;String> unique = new HashSet&lt&#xFEFF;>(list);
        this.items.clear();
        this.items.addAll(unique);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        boolean changed = false;
        if(!this.items.contains(word)) {
            this.items.add(word);
            changed = true;
        }
        return changed;
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && this.items.contains(target);
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                for(int i = 0; i &lt&#xFEFF; size(); i++) {
                    if(this.items.get(i).startsWith(prefix)) {
                        matches = Arrays.copyOf(matches, matches.length + 1);
                        matches[matches.length - 1] = this.items.get(i);
                    }
                }
            }
        }
        return matches;
    }
}

~~~~

# layout.fxml

~~~~ XML
&lt&#xFEFF;?xml version="1.0" encoding="UTF-8"?>

&lt&#xFEFF;?import javafx.scene.control.Button?>
&lt&#xFEFF;?import javafx.scene.control.Label?>
&lt&#xFEFF;?import javafx.scene.control.ListView?>
&lt&#xFEFF;?import javafx.scene.control.ScrollPane?>
&lt&#xFEFF;?import javafx.scene.control.TextField?>
&lt&#xFEFF;?import javafx.scene.layout.HBox?>
&lt&#xFEFF;?import javafx.scene.layout.VBox?>

&lt&#xFEFF;VBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="550.0" prefWidth="400.0" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="woodm.Controller">
   &lt&#xFEFF;children>
      &lt&#xFEFF;HBox prefHeight="30.0" prefWidth="300.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;Button fx:id="selectFileButton" mnemonicParsing="false" onAction="#selectFile" prefHeight="50.0" text="Select File" />
            &lt&#xFEFF;Label alignment="CENTER" prefHeight="30.0" prefWidth="50.0" text="Search" />
            &lt&#xFEFF;TextField fx:id="searchBar" editable="false" onKeyTyped="#updateList" prefHeight="30.0" prefWidth="280.0" />
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
      &lt&#xFEFF;ScrollPane hbarPolicy="NEVER" prefHeight="300.0" prefWidth="400.0" vbarPolicy="ALWAYS">
         &lt&#xFEFF;content>
            &lt&#xFEFF;ListView fx:id="listView" prefWidth="400.0" />
         &lt&#xFEFF;/content>&lt&#xFEFF;/ScrollPane>
      &lt&#xFEFF;HBox prefHeight="270.0" prefWidth="400.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;VBox prefHeight="248.0" prefWidth="150.0">
               &lt&#xFEFF;children>
                  &lt&#xFEFF;HBox prefHeight="20.0" prefWidth="160.0">
                     &lt&#xFEFF;children>
                        &lt&#xFEFF;Label prefHeight="20.0" prefWidth="75.0" text="Unsorted List" />
                        &lt&#xFEFF;Button fx:id="unsortedListALButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="AL" />
                        &lt&#xFEFF;Button fx:id="unsortedListLLButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="LL" />
                     &lt&#xFEFF;/children>
                  &lt&#xFEFF;/HBox>
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
                  &lt&#xFEFF;HBox prefHeight="20.0" prefWidth="160.0">
                     &lt&#xFEFF;children>
                        &lt&#xFEFF;Label prefHeight="20.0" prefWidth="75.0" text="Sorted List" />
                        &lt&#xFEFF;Button fx:id="sortedListALButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="AL" />
                        &lt&#xFEFF;Button fx:id="sortedListLLButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="LL" />
                     &lt&#xFEFF;/children>
                  &lt&#xFEFF;/HBox>
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="160.0" text="Binary Search Tree" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
               &lt&#xFEFF;/children>
            &lt&#xFEFF;/VBox>
            &lt&#xFEFF;VBox prefHeight="248.0" prefWidth="250.0">
               &lt&#xFEFF;children>
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="uLExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="uLAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="sLExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="sLAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="bSTExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="bSTAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
               &lt&#xFEFF;/children>
            &lt&#xFEFF;/VBox>
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
   &lt&#xFEFF;/children>
&lt&#xFEFF;/VBox>

~~~~

!!! BONUS: Nicely done
    I like your GUI.


# Commit Log

~~~~
Wed Mar 6 15:25 "AutoCompleter-Comments" # woodm@msoe.edu
Thu Mar 7 08:40 "format-implementation" # woodm@msoe.edu
Thu Mar 7 08:53 "UnorderedList-partial-implementation" # woodm@msoe.edu
Thu Mar 7 09:08 "getBackingClass-tests" # woodm@msoe.edu
Thu Mar 7 09:14 "UnorderedList-add-and-size-implementations" # woodm@msoe.edu
Thu Mar 7 09:19 "Additional-tests" # woodm@msoe.edu
Thu Mar 7 17:03 "Lab-Completed" # woodm@msoe.edu
Sat Mar 16 00:40 "Graded" # gitlab@taylor.bz
Thu Mar 28 09:12 "Ordered-List-stubs" # woodm@msoe.edu
Tue Apr 2 18:17 "GUI-Skeleton" # woodm@msoe.edu
Tue Apr 2 18:18 "GUI-Skeleton" # woodm@msoe.edu
Thu Apr 4 17:32 "Ordered-List-Functionality" # woodm@msoe.edu
Fri Apr 5 09:26 "Binary-Search-Tree-Functionality" # woodm@msoe.edu
Tue 00:46 "Lab-Completed" # woodm@msoe.edu
Tue 14:35 "Lab-Completed" # woodm@msoe.edu
Tue 14:36 "Lab-Completed" # woodm@msoe.edu
~~~~

<!-- Markdeep: --><script src="https://csse.msoe.us/markdeep.js?graded"></script>
