<meta charset="utf-8" lang="en">            <style class="fallback">body{visibility:hidden;}</style>
<!---


                       DOWNLOAD AND OPEN IN A BROWSER
                          TO SEE PROPER FORMATTING


--->
**Lab 13: Auto Complete Continued**
    Username: woodm
    Date: 04-24-2024
    Course: CSC1120
    Submitted to: Dr. Chris Taylor

!!! METRIcS: Instructor Feedback
    | Earned | Possible | Criteria                                         |
    | ------ | -------- | ------------------------------------------------ |
    |   55   |    55    | Technical quality (see point deductions in code) |
    |   15   |    15    | Instructor tests of `Trie` class                 |
    |   15   |    15    | Intermediate commits                             |
    |   10   |    10    | Coding standard compliance and program clarity   |
    |    5   |     5    | Following submission instructions                |

    [Nicely Done](https://msoe.us/taylor/Nice)

# AutoComplete.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;

/**
 * The Driver used to run the program.
 */
public class AutoComplete extends Application {
    public void start(Stage stage) {
        try {
            Parent pane = FXMLLoader.load(getClass().getResource("layout.fxml"));
            stage.setScene(new Scene(pane));
            stage.setTitle("Auto Complete");
            stage.setResizable(false);
            stage.show();
        } catch (IOException e) {
            System.out.println("There was an error reading the FXML file, please try again");
        }
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}

~~~~

# AutoCompleter.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/5/2024
 */
package woodm;

/**
 * The AutoCompleter interface represents an interface for implementing an auto-completion system
 * in your program. This interface defines methods and functionality related to providing
 * suggestions or completions based on user input.
 */
public interface AutoCompleter {
    /**
     * Adds a word to the AutoCompleter if the word is valid.
     * Duplicates and null values aren't allowed to be added.
     * @param word a string that is to be added to the AutoCompleter.
     * @return true if word is added to the object,
     * false if the word is already in the AutoCompleter.
     *
     * @throws IllegalArgumentException thrown if word is null or an empty string.
     */
    boolean add(String word) throws IllegalArgumentException;

    /**
     * Searches for a target in the AutoCompleter and returns true if it was found, false if not.
     * @param target the target to search for.
     * @return true if target is found in the AutoCompleter,
     * false if target is null or an empty string, or it was not found.
     */
    boolean exactMatch(String target);

    /**
     * Returns an integer representing the number of items in the AutoCompleter.
     * @return the number of items in the AutoCompleter.
     */
    int size();

    /**
     * returns a String indicating the fully qualified name of the data structure used to store
     * the words for the AutoCompleter.
     * @return a String indicating the name of the data structure used to store the words.
     */
    String getBackingClass();

    /**
     * Returns an array of all the strings in the object that begin with the prefix.
     * If prefix is an empty string, an array of all the strings in the auto completer are returned.
     * If prefix is null, an empty array is returned.
     * @param prefix the prefix to compare the words in the AutoCompleter to.
     * @return an array of all the strings in the object that begin with the prefix.
     */
    String[] allMatches(String prefix);

    /**
     * Returns a human-friendly string representing the number of nanoseconds.
     * @param nanoseconds the amount of nanoseconds it takes to complete the operation.
     * @return a human-friendly string representing the number of nanoseconds.
     */
    static String format(long nanoseconds) {
        final long nsInDay = 86_400_000_000_000L;
        final long nsToHr = 3_600_000_000_000L;
        final long nsInMin = 60_000_000_000L;
        final long nsInS = 1_000_000_000;
        final long nsInMs = 1_000_000;
        final long nsInMicros = 1_000;
        String time;
        if(nanoseconds / nsInDay >= 1) { // 2 day(s) 5 hour(s) 32 minute(s)
            long days = nanoseconds / nsInDay;
            nanoseconds %= nsInDay;
            long hours = nanoseconds / nsToHr;
            nanoseconds %= nsToHr;
            long minutes = Math.round((double) nanoseconds / nsInMin);
            time = days + " day(s) " + hours + " hour(s) " + minutes + " minute(s)";
        } else if(nanoseconds / nsToHr >= 1) { // 14 hour(s) 22 minute(s) 8 second(s)
            long hours = nanoseconds / nsToHr;
            nanoseconds %= nsToHr;
            long minutes = nanoseconds / nsInMin;
            nanoseconds %= nsInMin;
            long seconds = Math.round((double) nanoseconds / nsInS);
            time = hours + " hour(s) " + minutes + " minute(s) " + seconds + " second(s)";
        } else if(nanoseconds / nsInMin >= 1) { // 42 minute(s) 55.3 second(s)
            long minutes = nanoseconds / nsInMin;
            nanoseconds %= nsInMin;
            double seconds = (double) nanoseconds / nsInS;
            time = String.format("%d minute(s) %.1f second(s)", minutes, seconds);
        } else if(nanoseconds / nsInS >= 1) { // 18.8 second(s)
            double seconds = (double) nanoseconds / nsInS;
            time = String.format("%.1f second(s)", seconds);
        } else if(nanoseconds / nsInMs >= 1) { // 998.8 millisecond(s)
            double milliseconds = (double) nanoseconds / nsInMs;
            time = String.format("%.1f millisecond(s)", milliseconds);
        } else if(nanoseconds / nsInMicros >= 1) { // 318.8 microsecond(s)
            double microseconds = (double) nanoseconds / nsInMicros;
            time = String.format("%.1f microsecond(s)", microseconds);
        } else { // 7 nanosecond(s)
            time = nanoseconds + " nanosecond(s)";
        }
        return time;
    }
}

~~~~

# AutoCompleterTest.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/7/2024
 */
package woodm;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests to ensure all implementations of the AutoCompleter interface work properly.
 */
class AutoCompleterTest {
    private AutoCompleter autoCompleter;

    @BeforeEach
    void setUp() {
        autoCompleter = new HashTable(new ArrayList&lt&#xFEFF;>());
    }

    @AfterEach
    void tearDown() {
        autoCompleter = null;
    }

    @Test
    void getBackingClassTest() {
        autoCompleter = new UnorderedList(new ArrayList&lt&#xFEFF;>());
        assertEquals("java.util.ArrayList", autoCompleter.getBackingClass());
        autoCompleter = new OrderedList(new LinkedList&lt&#xFEFF;>());
        assertEquals("java.util.LinkedList", autoCompleter.getBackingClass());
        autoCompleter = new BinarySearchTree(new ArrayList&lt&#xFEFF;>());
        assertEquals("java.util.TreeSet", autoCompleter.getBackingClass());
        autoCompleter = new Trie(new ArrayList&lt&#xFEFF;>());
        assertEquals("woodm.ListMap", autoCompleter.getBackingClass());
        autoCompleter = new HashTable(new ArrayList&lt&#xFEFF;>());
        assertEquals("java.util.HashSet", autoCompleter.getBackingClass());
    }

    @Test
    void addTest() {
        assertTrue(autoCompleter.add("Hello"));
        assertFalse(autoCompleter.add("Hello"));
        assertTrue(autoCompleter.add("hello"));
        assertTrue(autoCompleter.add("help"));
        assertThrows(IllegalArgumentException.class, () -> autoCompleter.add(""));
        assertThrows(IllegalArgumentException.class, () -> autoCompleter.add(null));
    }

    @Test
    void sizeTest() {
        assertEquals(0, autoCompleter.size());
        autoCompleter.add("Hello");
        assertEquals(1, autoCompleter.size());
        autoCompleter.add("Hello");
        assertEquals(1, autoCompleter.size());
        autoCompleter.add("help");
        assertEquals(2, autoCompleter.size());
    }

    @Test
    void exactMatchTest() {
        autoCompleter.add("Hello");
        assertTrue(autoCompleter.exactMatch("Hello"));
        assertFalse(autoCompleter.exactMatch("hello"));
        autoCompleter.add("help");
        assertTrue(autoCompleter.exactMatch("help"));
        assertFalse(autoCompleter.exactMatch(null));
        assertFalse(autoCompleter.exactMatch(""));
    }

    @Test
    void allMatchesTest() {
        autoCompleter.add("hello");
        autoCompleter.add("hello world");
        autoCompleter.add("Hello");
        autoCompleter.add("hi");
        autoCompleter.add("help!");
        autoCompleter.add("h");
        String[] helMatches = {"hello", "hello world", "help!"};
        String[] hMatches = {"hello", "hello world", "hi", "help!", "h"};
        String[] matches = {"hello", "hello world", "Hello", "hi", "help!", "h"};
        Arrays.sort(helMatches);
        Arrays.sort(hMatches);
        Arrays.sort(matches);
        String[] actualHelMatches = autoCompleter.allMatches("hel");
        String[] actualHMatches = autoCompleter.allMatches("h");
        String[] actualAllMatches = autoCompleter.allMatches("");
        Arrays.sort(actualHelMatches);
        Arrays.sort(actualHMatches);
        Arrays.sort(actualAllMatches);
        assertArrayEquals(helMatches, actualHelMatches);
        assertArrayEquals(hMatches, actualHMatches);
        assertArrayEquals(new String[0], autoCompleter.allMatches(null));
        assertArrayEquals(new String[0], autoCompleter.allMatches("HI"));
        assertArrayEquals(matches, actualAllMatches);
    }

    @Test
    void formatTest() {
        final long test1 = 192_720_000_000_000L;
        final long test2 = 51_728_000_000_000L;
        final long test3 = 2_575_300_000_000L;
        final long test4 = 18_800_000_000L;
        final long test5 = 998_800_000;
        final long test6 = 318_800;
        final long test7 = 7;
        final long test8 = 998_799_980;
        final long test9 = 51_727_999_999_980L;
        long nanoseconds = test1;
        assertEquals("2 day(s) 5 hour(s) 32 minute(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test2;
        assertEquals("14 hour(s) 22 minute(s) 8 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test3;
        assertEquals("42 minute(s) 55.3 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test4;
        assertEquals("18.8 second(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test5;
        assertEquals("998.8 millisecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test6;
        assertEquals("318.8 microsecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test7;
        assertEquals("7 nanosecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test8;
        assertEquals("998.8 millisecond(s)", AutoCompleter.format(nanoseconds));
        nanoseconds = test9;
        assertEquals("14 hour(s) 22 minute(s) 8 second(s)", AutoCompleter.format(nanoseconds));
    }
}


/*
  Discussion: What method did you find most difficult to test? Why?

  I thought the allMatches() method was the most difficult to test because
  I was originally comparing the results of the method to another String array that has the
  same contents as what was expected. This resulted in the test failing when I used
  assertEquals because they aren't the same object. I then decided to use Arrays.equals inside
  the assertEquals and this worked. Then, I found out that the assertArrayEquals is the
  simplified version of this and that is what I ended up using.

*/

~~~~

# BinarySearchTree.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 4/4/2024
 */
package woodm;

import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A BinarySearchTree is a Binary Search Tree
 * that has a TreeSet backing class which doesn't allow duplicates.
 */
public class BinarySearchTree implements AutoCompleter {
    private final TreeSet&lt&#xFEFF;String> items;

    /**
     * Creates a new BinarySearchTree and adds all nodes from the treeSet
     * into the backing tree.
     * @param list the original tree set to pass in.
     *
     * @throws IllegalArgumentException thrown if the original tree set is null.
     */
    public BinarySearchTree(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = new TreeSet&lt&#xFEFF;>(list);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        return this.items.add(word);
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && this.items.contains(target);
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                SortedSet&lt&#xFEFF;String> matchSet =
                        this.items.subSet(prefix, prefix + Character.MAX_VALUE);
                matches = matchSet.toArray(new String[0]);
            }
        }
        return matches;
    }
}

~~~~

# Controller.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Alert;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.stage.FileChooser;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 * The Controller class is used to add functionality to the layout.fxml GUI
 */
public class Controller {
    private static final String DATA_FOLDER = "data/";
    @FXML
    private Button selectFileButton;
    @FXML
    private TextField searchBar;
    @FXML
    private Label totalSizeLabel;
    @FXML
    private Label searchSizeLabel;
    @FXML
    private ListView&lt&#xFEFF;String> listView;
    @FXML
    private TextField uLExactTime;
    @FXML
    private TextField uLAllMatchesTime;
    @FXML
    private TextField sLExactTime;
    @FXML
    private TextField sLAllMatchesTime;
    @FXML
    private TextField bSTExactTime;
    @FXML
    private TextField bSTAllMatchesTime;
    @FXML
    private TextField trieExactTime;
    @FXML
    private TextField trieAllMatchesTime;
    @FXML
    private Button unsortedListALButton;
    @FXML
    private Button unsortedListLLButton;
    @FXML
    private Button sortedListALButton;
    @FXML
    private Button sortedListLLButton;
    private File dataFile;
    private AutoCompleter unorderedList;
    private AutoCompleter orderedList;
    private AutoCompleter binarySearchTree;
    private AutoCompleter trie;
    private List&lt&#xFEFF;String> unorderedListBackingList;
    private List&lt&#xFEFF;String> orderedListBackingList;
    private final Background greenBackground;

    /**
     * Initializes the Controller and
     * initializes the unorderedListBackingList
     * and the orderedListBackingList
     * to empty ArrayLists
     */
    public Controller() {
        unorderedListBackingList = new ArrayList&lt&#xFEFF;>();
        orderedListBackingList = new ArrayList&lt&#xFEFF;>();
        greenBackground = new Background(
                new BackgroundFill(Color.LIGHTGREEN, null, null));
    }

    @FXML
    private void selectFile() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("Text Files", "*.txt"));
        fileChooser.setInitialDirectory(new File(DATA_FOLDER));
        File temp = fileChooser.showOpenDialog(null);
        if(temp != null) {
            if(unorderedListBackingList instanceof ArrayList&lt&#xFEFF;String>
                    && orderedListBackingList instanceof ArrayList&lt&#xFEFF;String>) {
                unsortedListALButton.setBackground(greenBackground);
                sortedListALButton.setBackground(greenBackground);
            }
            listView.getItems().clear();
            searchBar.setText("");
            changeTimesTextField(null, "", "", null);
            this.dataFile = temp;
            selectFileButton.setText(this.dataFile.getName());
            searchBar.setEditable(true);
            processFile();
            unsortedListALButton.setDisable(false);
            unsortedListLLButton.setDisable(false);
            sortedListALButton.setDisable(false);
            sortedListLLButton.setDisable(false);
        }
    }

    @FXML
    private void createBackingList(ActionEvent event) {
        Button button = (Button) event.getSource();
        String listType = ((Label) ((HBox) button.getParent()).getChildren().getFirst()).getText();
        if(button.getText().equals("LL")) {
            if(listType.equals("Unsorted List")
                    && !(unorderedListBackingList instanceof LinkedList&lt&#xFEFF;String>)) {
                unorderedListBackingList = new LinkedList&lt&#xFEFF;>(unorderedListBackingList);
                unorderedList = new UnorderedList(unorderedListBackingList);
                unsortedListLLButton.setBackground(greenBackground);
                unsortedListALButton.setBackground(null);
            } else if(listType.equals("Sorted List")
                    && !(orderedListBackingList instanceof LinkedList&lt&#xFEFF;String>)) {
                orderedListBackingList = new LinkedList&lt&#xFEFF;>(orderedListBackingList);
                orderedList = new OrderedList(orderedListBackingList);
                sortedListLLButton.setBackground(greenBackground);
                sortedListALButton.setBackground(null);
            }
        } else {
            if(listType.equals("Unsorted List")
                    && !(unorderedListBackingList instanceof ArrayList&lt&#xFEFF;String>)) {
                unorderedListBackingList = new ArrayList&lt&#xFEFF;>(unorderedListBackingList);
                unorderedList = new UnorderedList(unorderedListBackingList);
                unsortedListALButton.setBackground(greenBackground);
                unsortedListLLButton.setBackground(null);
            } else if(listType.equals("Sorted List")
                    && !(orderedListBackingList instanceof ArrayList&lt&#xFEFF;String>)) {
                orderedListBackingList = new ArrayList&lt&#xFEFF;>(orderedListBackingList);
                orderedList = new OrderedList(orderedListBackingList);
                sortedListALButton.setBackground(greenBackground);
                sortedListLLButton.setBackground(null);
            }
        }
    }

    private void processFile() {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        try (Scanner reader = new Scanner(dataFile)) {
            while(reader.hasNextLine()) {
                String line = reader.nextLine();
                unorderedListBackingList.add(line);
                orderedListBackingList.add(line);
            }
            unorderedList = new UnorderedList(unorderedListBackingList);
            orderedList = new OrderedList(orderedListBackingList);
            binarySearchTree = new BinarySearchTree(unorderedListBackingList);
            trie = new Trie(unorderedListBackingList);
            updateSizeLabels();
        } catch (IOException e) {
            alert.setContentText("The file could not be read, please try again");
            alert.showAndWait();
        } catch (IllegalArgumentException e) {
            alert.setContentText(e.getMessage());
            alert.showAndWait();
        }
    }

    @FXML
    private void updateUI() {
        if(searchBar.isEditable()) {
            listView.getItems().clear();
            String text = searchBar.getText();
            updateTimes(unorderedList, text);
            updateTimes(orderedList, text);
            updateTimes(binarySearchTree, text);
            updateTimes(trie, text);
            updateSizeLabels();
        }
    }

    private void updateTimes(AutoCompleter autoCompleter, String text) {
        long startTime = System.nanoTime();
        autoCompleter.exactMatch(text);
        String exactMatchTime = AutoCompleter.format(System.nanoTime() - startTime);
        startTime = System.nanoTime();
        String[] allMatches = autoCompleter.allMatches(text);
        String allMatchesTime = AutoCompleter.format(System.nanoTime() - startTime);
        changeTimesTextField(autoCompleter, exactMatchTime, allMatchesTime, allMatches);
    }

    private void changeTimesTextField(AutoCompleter autoCompleter, String exactMatchTime,
                                      String allMatchesTime, String[] allMatches) {
        if(autoCompleter instanceof UnorderedList) {
            uLExactTime.setText(exactMatchTime);
            uLAllMatchesTime.setText(allMatchesTime);
        } else if(autoCompleter instanceof OrderedList) {
            sLExactTime.setText(exactMatchTime);
            sLAllMatchesTime.setText(allMatchesTime);
            listView.getItems().addAll(allMatches);
        } else if(autoCompleter instanceof BinarySearchTree) {
            bSTExactTime.setText(exactMatchTime);
            bSTAllMatchesTime.setText(allMatchesTime);
        } else if(autoCompleter instanceof Trie) {
            trieExactTime.setText(exactMatchTime);
            trieAllMatchesTime.setText(allMatchesTime);
        } else {
            uLExactTime.setText("");
            uLAllMatchesTime.setText("");
            sLExactTime.setText("");
            sLAllMatchesTime.setText("");
            bSTExactTime.setText("");
            bSTAllMatchesTime.setText("");
        }
    }

    private void updateSizeLabels() {
        totalSizeLabel.setText("Total Size: " + unorderedList.size());
        searchSizeLabel.setText("Search Size: " + listView.getItems().size());
    }
}

~~~~

# HashTable.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 14 - Auto Completer Continued - HashTable
 * Name: Michael Wood
 * Created: 4/19/2024
 */
package woodm;

import java.util.HashSet;
import java.util.List;

/**
 * A HashTable
 */
public class HashTable implements AutoCompleter {
    private final HashSet&lt&#xFEFF;String> items;

    /**
     * Creates a new HashTable with a HashSet as its backing data structure.
     * @param items the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public HashTable(List&lt&#xFEFF;String> items) throws IllegalArgumentException {
        if(items == null) {
            throw new IllegalArgumentException();
        }
        this.items = new HashSet&lt&#xFEFF;>(items);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        return this.items.add(word);
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && this.items.contains(target);
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                matches = this.items.stream()
                        .filter(word -> word.startsWith(prefix))
                        .toArray(String[]::new);
            }
        }
        return matches;
    }
}

~~~~

# ListMap.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 13 - AutoCompleter with Trie
 * Name: Michael Wood
 * Created: 4/18/2024
 */
package woodm;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A ListMap that implements the Map interface is a Map
 * that uses a list as its backing data structure.
 * @param &lt&#xFEFF;K> the type of keys maintained by this map.
 * @param &lt&#xFEFF;V> the type of mapped values.
 */
public class ListMap&lt&#xFEFF;K, V> implements Map&lt&#xFEFF;K, V> {
    private final List&lt&#xFEFF;Map.Entry&lt&#xFEFF;K, V>> entries;

    /**
     * Creates a new ListMap with an ArrayList as its backing data structure.
     */
    public ListMap() {
        this.entries = new ArrayList&lt&#xFEFF;>();
    }

    @Override
    public boolean containsKey(Object key) {
        boolean found = false;
        for(int i = 0; !found && i &lt&#xFEFF; this.entries.size(); i++) {
            if(this.entries.get(i).getKey().equals(key)) {
                found = true;
            }
        }
        return found;
    }

    @Override
    public V get(Object key) {
        V value = null;
        for(int i = 0; value == null && i &lt&#xFEFF; this.entries.size(); i++) {
            if(this.entries.get(i).getKey().equals(key)) {
                value = this.entries.get(i).getValue();
            }
        }
        return value;
    }

    @Override
    public V put(K key, V value) {
        V oldValue = this.remove(key);
        this.entries.add(new AbstractMap.SimpleEntry&lt&#xFEFF;>(key, value));
        return oldValue;
    }

    @Override
    public V remove(Object key) {
        boolean removed = false;
        V value = null;
        for(int i = 0; !removed && i &lt&#xFEFF; this.entries.size(); i++) {
            if(this.entries.get(i).getKey().equals(key)) {
                value = this.entries.remove(i).getValue();
                removed = true;
            }
        }
        return value;
    }

    @Override
    public Set&lt&#xFEFF;Entry&lt&#xFEFF;K, V>> entrySet() {
        return new HashSet&lt&#xFEFF;>(this.entries);
    }

    @Override
    public void clear() {
        this.entries.clear();
    }

    @Override
    public int size() {
        return this.entries.size();
    }

    @Override
    public boolean isEmpty() {
        return this.entries.isEmpty();
    }

    @Override
    public Set&lt&#xFEFF;K> keySet() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }

    @Override
    public Collection&lt&#xFEFF;V> values() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean containsValue(Object value) throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }

    @Override
    public void putAll(Map m) throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }
}

~~~~

# MapTest.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 13 - AutoCompleter with Trie
 * Name: Michael Wood
 * Created: 4/18/2024
 */
package woodm;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;

import java.util.Map;

/**
 * Test for a subset of the Map interface that must be implemented
 * as part of the week 13 lab assignment.
 */
class MapTest {

    private Map&lt&#xFEFF;Integer, Integer> map;

    @BeforeEach
    void setup() {
        map = new ListMap&lt&#xFEFF;>();
    }

    @org.junit.jupiter.api.Test
    void sizeAndClear() {
        Assertions.assertEquals(0, map.size());
        map.clear();
        Assertions.assertEquals(0, map.size());
        map.put(0, 0);
        Assertions.assertEquals(1, map.size());
        map.clear();
        Assertions.assertEquals(0, map.size());
        map.put(0, 0);
        map.put(-2, 0);
        Assertions.assertEquals(2, map.size());
        map.clear();
        Assertions.assertEquals(0, map.size());
    }

    @org.junit.jupiter.api.Test
    void containsKey() {
        Assertions.assertFalse(map.containsKey(0));
        Assertions.assertFalse(map.containsKey(1));
        map.put(0, 0);
        Assertions.assertTrue(map.containsKey(0));
        Assertions.assertFalse(map.containsKey(1));
        map.put(1, 0);
        Assertions.assertTrue(map.containsKey(0));
        Assertions.assertTrue(map.containsKey(1));
        Assertions.assertFalse(map.containsKey(-1));
    }

    @org.junit.jupiter.api.Test
    void get() {
        Assertions.assertNull(map.get(0));
        map.put(0, 2);
        Assertions.assertEquals(2, map.get(0));
        Assertions.assertNull(map.get(2));
        map.put(-1, -2);
        Assertions.assertEquals(-2, map.get(-1));
        Assertions.assertNull(map.get(-2));
    }

    @org.junit.jupiter.api.Test
    void isEmpty() {
        Assertions.assertTrue(map.isEmpty());
        map.put(0, 10);
        Assertions.assertFalse(map.isEmpty());
    }

    @org.junit.jupiter.api.Test
    void put() {
        Assertions.assertNull(map.get(0));
        Assertions.assertNull(map.put(0, 2));
        Assertions.assertEquals(2, map.get(0));
        Assertions.assertNull(map.get(2));
        Assertions.assertEquals(2, map.put(0, 1));
        Assertions.assertEquals(1, map.get(0));
        map.put(-1, -2);
        Assertions.assertEquals(-2, map.get(-1));
        Assertions.assertNull(map.get(-2));
    }

    @org.junit.jupiter.api.Test
    void remove() {
        Assertions.assertNull(map.remove(0), "Should return null if item to remove is not present");
        map.put(0, 0);
        map.put(1, 1);
        Assertions.assertNull(map.remove(2), "Should return null if item to remove is not present");
        Assertions.assertEquals(0, map.remove(0));
        Assertions.assertEquals(1, map.size());
        Assertions.assertNull(map.remove(0));
        Assertions.assertEquals(1, map.remove(1));
        Assertions.assertEquals(0, map.size());
    }
}
~~~~

# OrderedList.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 11 - Auto Complete
 * Name: Michael Wood
 * Created: 3/28/2024
 */
package woodm;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

/**
 * An OrderedList is a list that has an order and doesn't allow duplicates.
 */
public class OrderedList implements AutoCompleter {
    private final List&lt&#xFEFF;String> items;

    /**
     * Creates a new OrderedList that removes all duplicates from the original list
     * and puts all items in order alphabetically.
     * @param list the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public OrderedList(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = list;
        Set&lt&#xFEFF;String> unique = new HashSet&lt&#xFEFF;>(list);
        this.items.clear();
        this.items.addAll(unique);
        Collections.sort(items);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        boolean changed = false;
        ListIterator&lt&#xFEFF;String> iterator = this.items.listIterator();
        if(!items.contains(word)) {
            if (!iterator.hasNext() && !iterator.hasPrevious()) {
                iterator.add(word);
                changed = true;
            } else if (iterator.hasNext() && iterator.next().compareTo(word) &lt&#xFEFF; 0) {
                iterator.previous();
                while (iterator.hasNext() && !changed) {
                    String currentWord = iterator.next();
                    if (currentWord.compareTo(word) > 0) {
                        iterator.previous();
                        iterator.add(word);
                        changed = true;
                    }
                }
                if(!changed) {
                    iterator.add(word);
                    changed = true;
                }
            } else {
                if(iterator.hasPrevious()) {
                    iterator.previous();
                }
                iterator.add(word);
                changed = true;
            }
        }
        return changed;
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty()
                && Collections.binarySearch(this.items, target) >= 0;
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                int index = Collections.binarySearch(this.items, prefix);
                if(index &lt&#xFEFF; 0) {
                    index = -index - 1;
                }
                List&lt&#xFEFF;String> matchesList = new ArrayList&lt&#xFEFF;>();
                while(index &lt&#xFEFF; items.size() && items.get(index).startsWith(prefix)) {
                    matchesList.add(items.get(index));
                    index++;
                }
                matches = matchesList.toArray(new String[0]);
            }
        }
        return matches;
    }
}

~~~~

# Trie.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 13 - AutoCompleter with Trie
 * Name: Michael Wood
 * Created: 4/18/2024
 */
package woodm;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * A Trie is a tree with an arbitrary amount of children which
 * stores each string as a chain of characters.
 */
public class Trie implements AutoCompleter {

    private boolean endsWord;
    private final Map&lt&#xFEFF;Character, Trie> edges;
    private int size;


    /**
     * Creates a new Trie with no words in it.
     */
    public Trie() {
        this.endsWord = false;
        this.edges = new ListMap&lt&#xFEFF;>();
        this.size = 0;
    }

    /**
     * Creates a new Trie with a starting list of words.
     * @param list the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public Trie(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        this();
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        for (String word : list) {
            this.add(word);
        }
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        return add(word, this);
    }

    private boolean add(String word, Trie node) {
        boolean changed = false;
        if(word.isEmpty()) {
            if(!node.endsWord) {
                node.endsWord = true;
                changed = true;
                this.size++;
            }
        } else {
            char letter = word.charAt(0);
            if(!node.edges.containsKey(letter)) {
                node.edges.put(letter, new Trie());
            }
            Trie nextNode = node.edges.get(letter);
            changed = add(word.substring(1), nextNode);
        }
        return changed;
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && exactMatch(target, this);
    }

    private boolean exactMatch(String target, Trie node) {
        boolean found = false;
        if(target.isEmpty()) {
            if(node.endsWord) {
                found = true;
            }
        } else {
            char letter = target.charAt(0);
            if(node.edges.containsKey(letter)) {
                Trie nextNode = node.edges.get(letter);
                found = exactMatch(target.substring(1), nextNode);
            }
        }
        return found;
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public String getBackingClass() {
        return ListMap.class.getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        List&lt&#xFEFF;String> matches = new ArrayList&lt&#xFEFF;>();
        if(prefix != null) {
            Trie node = this;
            if(!prefix.isEmpty()) {
                node = findPrefixNode(this, prefix);
            }
            allMatches(prefix, node, matches);
        }
        return matches.toArray(new String[0]);
    }

    private void allMatches(String prefix, Trie node, List&lt&#xFEFF;String> matches) {
        if(node != null) {
            if(node.endsWord) {
                matches.add(prefix);
            }
            for(Map.Entry&lt&#xFEFF;Character, Trie> entry : node.edges.entrySet()) {
                char letter = entry.getKey();
                Trie nextNode = entry.getValue();
                allMatches(prefix + letter, nextNode, matches);
            }
        }
    }

    private Trie findPrefixNode(Trie node, String prefix) {
        Trie nextNode = null;
        if(!prefix.isEmpty()) {
            char letter = prefix.charAt(0);
            if(prefix.substring(1).isEmpty()) {
                nextNode = node.edges.get(letter);
            } else if(node.edges.containsKey(letter)) {
                nextNode = findPrefixNode(node.edges.get(letter), prefix.substring(1));
            }
        }
        return nextNode;
    }
}

~~~~

# UnorderedList.java

~~~~ Java
/*
 * Course: CSC1120A 121
 * Spring 2023
 * Lab 8 - JUnit testing
 * Name: Michael Wood
 * Created: 3/7/2024
 */
package woodm;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * An UnorderedList is a list that has no order and doesn't allow duplicates.
 */
public class UnorderedList implements AutoCompleter {
    private final List&lt&#xFEFF;String> items;

    /**
     * Creates a new UnorderedList that removes all duplicates from the original list.
     * @param list the original list to pass in.
     *
     * @throws IllegalArgumentException thrown if the original list is null.
     */
    public UnorderedList(List&lt&#xFEFF;String> list) throws IllegalArgumentException {
        if(list == null) {
            throw new IllegalArgumentException("Please ensure your list is not null");
        }
        this.items = list;
        Set&lt&#xFEFF;String> unique = new HashSet&lt&#xFEFF;>(list);
        this.items.clear();
        this.items.addAll(unique);
    }

    @Override
    public boolean add(String word) throws IllegalArgumentException {
        if(word == null || word.isEmpty()) {
            throw new IllegalArgumentException("Please ensure the word you want to add" +
                    " isn't empty or null");
        }
        boolean changed = false;
        if(!this.items.contains(word)) {
            this.items.add(word);
            changed = true;
        }
        return changed;
    }

    @Override
    public boolean exactMatch(String target) {
        return target != null && !target.isEmpty() && this.items.contains(target);
    }

    @Override
    public int size() {
        return this.items.size();
    }

    @Override
    public String getBackingClass() {
        return this.items.getClass().getName();
    }

    @Override
    public String[] allMatches(String prefix) {
        String[] matches = new String[0];
        if(prefix != null) {
            if(prefix.isEmpty()) {
                matches = this.items.toArray(new String[size()]);
            } else {
                List&lt&#xFEFF;String> matchesList = new ArrayList&lt&#xFEFF;>();
                for(String word : this.items) {
                    if(word.startsWith(prefix)) {
                        matchesList.add(word);
                    }
                }
                matches = matchesList.toArray(new String[0]);
            }
        }
        return matches;
    }
}

~~~~

# layout.fxml

~~~~ XML
&lt&#xFEFF;?xml version="1.0" encoding="UTF-8"?>

&lt&#xFEFF;?import javafx.scene.control.Button?>
&lt&#xFEFF;?import javafx.scene.control.Label?>
&lt&#xFEFF;?import javafx.scene.control.ListView?>
&lt&#xFEFF;?import javafx.scene.control.ScrollPane?>
&lt&#xFEFF;?import javafx.scene.control.TextField?>
&lt&#xFEFF;?import javafx.scene.layout.HBox?>
&lt&#xFEFF;?import javafx.scene.layout.VBox?>

&lt&#xFEFF;VBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="655.0" prefWidth="400.0" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="woodm.Controller">
   &lt&#xFEFF;children>
      &lt&#xFEFF;HBox prefHeight="30.0" prefWidth="300.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;Button fx:id="selectFileButton" mnemonicParsing="false" onAction="#selectFile" prefHeight="50.0" text="Select File" />
            &lt&#xFEFF;Label alignment="CENTER" prefHeight="30.0" prefWidth="50.0" text="Search" />
            &lt&#xFEFF;TextField fx:id="searchBar" editable="false" onKeyTyped="#updateUI" prefHeight="30.0" prefWidth="280.0" />
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
      &lt&#xFEFF;ScrollPane hbarPolicy="NEVER" prefHeight="300.0" prefWidth="400.0" vbarPolicy="ALWAYS">
         &lt&#xFEFF;content>
            &lt&#xFEFF;ListView fx:id="listView" prefWidth="400.0" />
         &lt&#xFEFF;/content>&lt&#xFEFF;/ScrollPane>
      &lt&#xFEFF;HBox prefHeight="25.0" prefWidth="200.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;Label fx:id="totalSizeLabel" prefHeight="25.0" prefWidth="200.0" text="Total Size: " />
            &lt&#xFEFF;Label fx:id="searchSizeLabel" prefHeight="25.0" prefWidth="200.0" text="Search Size: " />
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
      &lt&#xFEFF;HBox prefHeight="300.0" prefWidth="400.0">
         &lt&#xFEFF;children>
            &lt&#xFEFF;VBox prefHeight="260.0" prefWidth="150.0">
               &lt&#xFEFF;children>
                  &lt&#xFEFF;HBox prefHeight="20.0" prefWidth="160.0">
                     &lt&#xFEFF;children>
                        &lt&#xFEFF;Label prefHeight="20.0" prefWidth="75.0" text="Unsorted List" />
                        &lt&#xFEFF;Button fx:id="unsortedListALButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="AL" />
                        &lt&#xFEFF;Button fx:id="unsortedListLLButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="LL" />
                     &lt&#xFEFF;/children>
                  &lt&#xFEFF;/HBox>
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
                  &lt&#xFEFF;HBox prefHeight="20.0" prefWidth="160.0">
                     &lt&#xFEFF;children>
                        &lt&#xFEFF;Label prefHeight="20.0" prefWidth="75.0" text="Sorted List" />
                        &lt&#xFEFF;Button fx:id="sortedListALButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="AL" />
                        &lt&#xFEFF;Button fx:id="sortedListLLButton" disable="true" mnemonicParsing="false" onAction="#createBackingList" prefHeight="20.0" prefWidth="35.0" text="LL" />
                     &lt&#xFEFF;/children>
                  &lt&#xFEFF;/HBox>
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="160.0" text="Binary Search Tree" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="All Matches Time" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="160.0" text="Trie" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="160.0" text="Exact Query Time" />
                  &lt&#xFEFF;Label alignment="TOP_LEFT" prefHeight="30.0" prefWidth="150.0" text="All Matches Time" />
               &lt&#xFEFF;/children>
            &lt&#xFEFF;/VBox>
            &lt&#xFEFF;VBox prefHeight="248.0" prefWidth="250.0">
               &lt&#xFEFF;children>
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="uLExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="uLAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="sLExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="sLAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="bSTExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="bSTAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;Label prefHeight="20.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="trieExactTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
                  &lt&#xFEFF;TextField fx:id="trieAllMatchesTime" editable="false" prefHeight="30.0" prefWidth="250.0" />
               &lt&#xFEFF;/children>
            &lt&#xFEFF;/VBox>
         &lt&#xFEFF;/children>
      &lt&#xFEFF;/HBox>
   &lt&#xFEFF;/children>
&lt&#xFEFF;/VBox>

~~~~

# Additional Instructor Tests

## Instructor Tests

### Tests for `Trie.add()` and `Trie.exactMatch()`
- &#x02714; Correctly added by.
- &#x02714; Correctly added sea.
- &#x02714; Correctly added she.
- &#x02714; Correctly added shells.
- &#x02714; Can still find "she" after "shells" was added.

### Tests for `Trie.add()` and `Trie.size()`
- &#x02714; Correct size after adding by.
- &#x02714; Correct size after adding sea.
- &#x02714; Correct size after adding she.
- &#x02714; Correct size after adding shells.

### Tests for `Trie.allMatches()` with she, sells, sea, and shells in Trie
- &#x02714; Correct result on `allMatches("s")`.
- &#x02714; Correct result on `allMatches("se")`.
- &#x02714; Correct result on `allMatches("sh")`.
- &#x02714; Correct result on `allMatches("she")`.
- &#x02714; Correct result on `allMatches("sel")`.
- &#x02714; Correct result on `allMatches("sea")`.

# Commit Log

~~~~
Wed Mar 6 15:25 "AutoCompleter-Comments" # woodm@msoe.edu
Thu Mar 7 08:40 "format-implementation" # woodm@msoe.edu
Thu Mar 7 08:53 "UnorderedList-partial-implementation" # woodm@msoe.edu
Thu Mar 7 09:08 "getBackingClass-tests" # woodm@msoe.edu
Thu Mar 7 09:14 "UnorderedList-add-and-size-implementations" # woodm@msoe.edu
Thu Mar 7 09:19 "Additional-tests" # woodm@msoe.edu
Thu Mar 7 17:03 "Lab-Completed" # woodm@msoe.edu
Sat Mar 16 00:40 "Graded" # gitlab@taylor.bz
Thu Mar 28 09:12 "Ordered-List-stubs" # woodm@msoe.edu
Tue Apr 2 18:17 "GUI-Skeleton" # woodm@msoe.edu
Tue Apr 2 18:18 "GUI-Skeleton" # woodm@msoe.edu
Thu Apr 4 17:32 "Ordered-List-Functionality" # woodm@msoe.edu
Fri Apr 5 09:26 "Binary-Search-Tree-Functionality" # woodm@msoe.edu
Tue Apr 9 00:46 "Lab-Completed" # woodm@msoe.edu
Tue Apr 9 14:35 "Lab-Completed" # woodm@msoe.edu
Tue Apr 9 14:36 "Lab-Completed" # woodm@msoe.edu
Wed Apr 10 07:34 "Graded" # gitlab@taylor.bz
Thu Apr 18 01:07 "ListMap-Stubs" # woodm@msoe.edu
Thu Apr 18 09:09 "ListMap-Implementation" # woodm@msoe.edu
Thu Apr 18 09:22 "Trie-Stubs" # woodm@msoe.edu
Fri Apr 19 09:31 "Lab-completed" # woodm@msoe.edu
Fri Apr 19 12:49 "Lab-completed" # woodm@msoe.edu
Tue 16:39 "HashSet-Implementation-of-AutoCompleter" # woodm@msoe.edu
~~~~

<!-- Markdeep: --><script src="https://csse.msoe.us/markdeep.js?graded"></script>
